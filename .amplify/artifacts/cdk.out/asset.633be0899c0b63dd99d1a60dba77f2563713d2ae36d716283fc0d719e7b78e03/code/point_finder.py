"""Detects objects as points heatmaps (as generated by a tf classifier nn)"""
import skimage
import numpy as np
from scipy import ndimage

from math import hypot, ceil

class PointFinder():
    """PointFinder - finds interesting points in a single heatmap."""

    def __init__(self, threshold=0.8, smoothing_flag=True, smoothing_dl = 3):
        self.threshold = threshold
        self.smoothing_flag = smoothing_flag 
        self.smoothing_dl = smoothing_dl

    def smooth(self, np_array):
        """Smooth an array."""
        return ndimage.morphology.grey_dilation(np_array, size=(self.smoothing_dl, 
                                                                self.smoothing_dl))

    def detect(self, heatmap):
        """Find objects within the numpy heatmap.
        
        Return a list of lists, where each list is the point x, point y and
        heatmap value at that point.
        """
        pts = []

        if self.smoothing_flag:
            heatmap = self.smooth(heatmap)

        labels = skimage.measure.label(heatmap > self.threshold)
        regions = skimage.measure.regionprops(labels, heatmap)
        for region in regions:
            centroid_yx = np.round(region.weighted_centroid)
            hm_value = heatmap[int(round(centroid_yx[0])), int(round(centroid_yx[1]))]
            pt = {'x': centroid_yx[1], 'y': centroid_yx[0], 'hm_value':
                  hm_value}
            pts.append(pt)
 
        return pts

class MultiClassPointFinder():
    """PointFinder for multiple category heatmaps."""

    def __init__(self, threshold=0.8, smoothing_flag=True, hm_dist_threshold=2,
                 excl_classes=None, smoothing_dl=3):
        self.threshold = threshold
        self.smoothing_flag = True
        self.smoothing_dl = smoothing_dl
        self.hm_dist_threshold = hm_dist_threshold
        if excl_classes is None:
            self.excl_classes = []
        else:
            self.excl_classes = excl_classes

    def detect(self, heatmap):
        """Detect points in all heatmaps."""
        pf = PointFinder(self.threshold, self.smoothing_flag, 
                         smoothing_dl = self.smoothing_dl)
        num_classes = heatmap.shape[2]

        pts = []
        for class_index in range(num_classes):
            if class_index in self.excl_classes:
                continue
            class_pts = pf.detect(heatmap[:, :, class_index])
            for pt in class_pts:
                pt['class'] = class_index
                pts.append(pt)

        #print('num pts generated: %d' %len(pts))

        # remove overlapping pts
        # (disabling for now)
        final_pts = pts
        # final_pts = []
        # for ai in range(0, len(pts)-1):
        #    too_close = False 
        #    for bi in range(ai+1, len(pts)):
        #       if hypot(pts[ai]['x'] - pts[bi]['x'], pts[ai]['y'] -
        #                pts[bi]['y']) < self.hm_dist_threshold:
        #           too_close = True
        #           break
        #    if too_close is False:
        #        final_pts.append(pts[ai])

        #print('num pts accepted: %d' %len(final_pts))
        return final_pts


class NaiveBlockPointFinder():
    """Find points by thresholding to get binary image, and gridding the shapes."""
    def __init__(self, threshold=0.8, smoothing_flag=True, block_length=int(200/32), smoothing_dl=3):
        self.threshold = threshold
        self.smoothing_flag = smoothing_flag 
        self.smoothing_dl = smoothing_dl
        self.blen = block_length

    def smooth(self, np_array):
        """Smooth an array."""
        return ndimage.morphology.grey_dilation(np_array, size=(self.smoothing_dl,self.smoothing_dl))

    def detect(self, heatmap):
        """Find objects within the numpy heatmap.
        
        Return a list of lists, where each list is the point x, point y and
        heatmap value at that point.
        """
        pts = []

        if self.smoothing_flag:
            heatmap = self.smooth(heatmap)

        hm_threshed = heatmap > self.threshold
        labels = skimage.measure.label(heatmap > self.threshold)
        regions = skimage.measure.regionprops(labels, heatmap)
        for region in regions:
            bbox = region.bbox

            bw = bbox[3]-bbox[1]
            num_w_divs = ceil(bw/self.blen)
            w_blocks = int(num_w_divs*self.blen)
            w_diff = w_blocks-bw
            w_start = int(bbox[1] - w_diff/2)            

            bh = bbox[2] - bbox[0]
            num_h_divs = ceil(bh/self.blen)
            h_blocks = int(num_h_divs*self.blen)
            h_start = int(bbox[0] - (h_blocks-bh)/2)

            for w in range(w_start, w_start+w_blocks, self.blen):
                w_end = w + self.blen
                if w_end >= heatmap.shape[1]:
                    w_end = heatmap.shape[1]

                w_begin = w
                if w_begin < 0:
                    w_begin = 0

                for h in range(h_start, h_start+h_blocks, self.blen):
                    h_end = h + self.blen
                    if h_end >= heatmap.shape[0]:
                        h_end = heatmap.shape[0]

                    h_begin = h
                    if h_begin < 0:
                        h_begin = 0

                    block = hm_threshed[h_begin:h_end, w_begin:w_end]
                    if block.sum() > 0:
                        x = int((w_begin+w_end)/2)                        
                        y = int((h_begin+h_end)/2)
                        hm_value = heatmap[h_begin:h_end, w_begin:w_end].max()
                        pt = {'x': x, 'y': y, 'hm_value': hm_value}
                        pts.append(pt)

            # centroid_yx = np.round(region.weighted_centroid)
            # hm_value = heatmap[int(round(centroid_yx[0])), int(round(centroid_yx[1]))]
            # pt = {'x': centroid_yx[1], 'y': centroid_yx[0], 'hm_value':
                  # hm_value}
            # pts.append(pt)
 
        return pts


class TightBlockPointFinder():
    """Find points by thresholding to get binary image, and gridding the shapes, but tightly."""
    def __init__(self, threshold=0.8, smoothing_flag=True, block_length=int(200/32), smoothing_dl=3):
        self.threshold = threshold
        self.smoothing_flag = smoothing_flag 
        self.smoothing_dl = smoothing_dl
        self.blen = block_length

    def smooth(self, np_array):
        """Smooth an array."""
        return ndimage.morphology.grey_dilation(np_array, size=(self.smoothing_dl, self.smoothing_dl))

    def detect(self, heatmap):
        """Find objects within the numpy heatmap.
        
        Return a list of lists, where each list is the point x, point y and
        heatmap value at that point.
        """
        pts = []

        if self.smoothing_flag:
            heatmap = self.smooth(heatmap)

        hm_threshed = heatmap > self.threshold
        labels = skimage.measure.label(hm_threshed)
        regions = skimage.measure.regionprops(labels, heatmap)
        for region in regions:
            bbox = region.bbox

            bw = bbox[3]-bbox[1]
            num_w_divs = ceil(bw/self.blen)
            w_blocks = int(num_w_divs*self.blen)
            w_diff = w_blocks-bw
            w_start = int(bbox[1] - w_diff/2)            

            bh = bbox[2] - bbox[0]
            num_h_divs = ceil(bh/self.blen)
            h_blocks = int(num_h_divs*self.blen)
            h_start = int(bbox[0] - (h_blocks-bh)/2)

            for w in range(w_start, w_start+w_blocks, self.blen):
                for h in range(h_start, h_start+h_blocks, self.blen):
                    h_end = h + self.blen
                    if h_end >= heatmap.shape[0]:
                        h_end = heatmap.shape[0]

                    w_end = w + self.blen
                    if w_end >= heatmap.shape[1]:
                        w_end = heatmap.shape[1]

                    block = hm_threshed[h:h_end, w:w_end]
                    if block.sum() > 0:
                        x = int((w+w_end)/2)                        
                        y = int((h+h_end)/2)
                        hm_value = heatmap[h:h_end, w:w_end].max()
                        pt = {'x': x, 'y': y, 'hm_value': hm_value}
                        pts.append(pt)

            # centroid_yx = np.round(region.weighted_centroid)
            # hm_value = heatmap[int(round(centroid_yx[0])), int(round(centroid_yx[1]))]
            # pt = {'x': centroid_yx[1], 'y': centroid_yx[0], 'hm_value':
                  # hm_value}
            # pts.append(pt)
 
        return pts



class SumBlockPointFinder():
    """Find points by thresholding to get binary image, and gridding the shapes. Feature value is assigned as the sum of
    the block."""
    def __init__(self, threshold=0.8, smoothing_flag=True, block_length=int(200/32), smoothing_dl=3):
        self.threshold = threshold
        self.smoothing_flag = smoothing_flag 
        self.smoothing_dl = smoothing_dl
        self.blen = block_length

    def smooth(self, np_array):
        """Smooth an array."""
        return ndimage.morphology.grey_dilation(np_array, size=(self.smoothing_dl,self.smoothing_dl))

    def compute_hm_value(self, block):
        """HM Value is equal to the sum of the block."""
        return np.sum(block)

    def detect(self, heatmap):
        """Find objects within the numpy heatmap.
        
        Return a list of lists, where each list is the point x, point y and
        heatmap value at that point.
        """
        pts = []

        if self.smoothing_flag:
            heatmap = self.smooth(heatmap)

        hm_threshed = heatmap > self.threshold
        labels = skimage.measure.label(heatmap > self.threshold)
        regions = skimage.measure.regionprops(labels, heatmap)
        for region in regions:
            bbox = region.bbox

            bw = bbox[3]-bbox[1]
            num_w_divs = ceil(bw/self.blen)
            w_blocks = int(num_w_divs*self.blen)
            w_diff = w_blocks-bw
            w_start = int(bbox[1] - w_diff/2)            

            bh = bbox[2] - bbox[0]
            num_h_divs = ceil(bh/self.blen)
            h_blocks = int(num_h_divs*self.blen)
            h_start = int(bbox[0] - (h_blocks-bh)/2)

            for w in range(w_start, w_start+w_blocks, self.blen):
                w_end = w + self.blen
                if w_end >= heatmap.shape[1]:
                    w_end = heatmap.shape[1]

                w_begin = w
                if w_begin < 0:
                    w_begin = 0

                for h in range(h_start, h_start+h_blocks, self.blen):
                    h_end = h + self.blen
                    if h_end >= heatmap.shape[0]:
                        h_end = heatmap.shape[0]

                    h_begin = h
                    if h_begin < 0:
                        h_begin = 0

                    block = hm_threshed[h_begin:h_end, w_begin:w_end]
                    if block.sum() > 0:
                        x = int((w_begin+w_end)/2)                        
                        y = int((h_begin+h_end)/2)
                        hm_value = self.compute_hm_value(heatmap[h_begin:h_end, w_begin:w_end])
                        pt = {'x': x, 'y': y, 'hm_value': hm_value}
                        pts.append(pt)

            # centroid_yx = np.round(region.weighted_centroid)
            # hm_value = heatmap[int(round(centroid_yx[0])), int(round(centroid_yx[1]))]
            # pt = {'x': centroid_yx[1], 'y': centroid_yx[0], 'hm_value':
                  # hm_value}
            # pts.append(pt)
 
        return pts


class MultiTypeBlockPointFinder():
    """Find points by thresholding to get binary image, and gridding the shapes. Feature value is assigned as the sum of
    the block."""
    def __init__(self, threshold=0.8, smoothing_flag=True, block_width=1024,block_height=1024, smoothing_dl=10):
        self.threshold = threshold
        self.smoothing_flag = smoothing_flag 
        self.smoothing_dl = smoothing_dl
        self.bheight=int(block_height/32)
        self.bwidth=int(block_width/32)

    def smooth(self, np_array):
        """Smooth an array."""
        return ndimage.morphology.grey_dilation(np_array, size=(self.smoothing_dl,self.smoothing_dl))

    def compute_hm_values(self, block):
        """HM Value is equal to the sum of the block."""
        return np.sum(block), np.max(block)

    def detect(self, heatmap):
        """Find objects within the numpy heatmap.
        
        Return a list of lists, where each list is the point x, point y and
        heatmap value at that point.
        """
        pts = []

        if self.smoothing_flag:
            heatmap = self.smooth(heatmap)

        hm_threshed = heatmap > self.threshold
        labels = skimage.measure.label(heatmap > self.threshold)
        regions = skimage.measure.regionprops(labels, heatmap)
        for region in regions:
            bbox = region.bbox

            bw = bbox[3]-bbox[1]
            num_w_divs = ceil(bw/self.bwidth)
            w_blocks = int(num_w_divs*self.bwidth)
            w_diff = w_blocks-bw
            w_start = int(bbox[1] - w_diff/2)            

            bh = bbox[2] - bbox[0]
            num_h_divs = ceil(bh/self.bheight)
            h_blocks = int(num_h_divs*self.bheight)
            h_start = int(bbox[0] - (h_blocks-bh)/2)

            for w in range(w_start, w_start+w_blocks, self.bwidth):
                w_end = w + self.bwidth
                if w_end >= heatmap.shape[1]:
                    w_end = heatmap.shape[1]

                w_begin = w
                if w_begin < 0:
                    w_begin = 0

                for h in range(h_start, h_start+h_blocks, self.bheight):
                    h_end = h + self.bheight
                    if h_end >= heatmap.shape[0]:
                        h_end = heatmap.shape[0]

                    h_begin = h
                    if h_begin < 0:
                        h_begin = 0

                    block = hm_threshed[h_begin:h_end, w_begin:w_end]
                    if block.sum() > 0:
                        x = int((w_begin+w_end)/2)                        
                        y = int((h_begin+h_end)/2)
                        hm_values = self.compute_hm_values(heatmap[h_begin:h_end, w_begin:w_end])
                        pt = {'x': x, 'y': y,
                              'features' : {'hm_block_sum': hm_values[0],
                                            'hm_block_max': hm_values[1]}
                             }
                        pts.append(pt)

        return pts


    
