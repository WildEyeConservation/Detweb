import { useContext, useEffect, useState } from 'react';
import { Button, Row, Tooltip, OverlayTrigger, Col } from 'react-bootstrap';
import { UserContext, ManagementContext } from './Context';
import MyTable from './Table';
import { PurgeQueueCommand, GetQueueAttributesCommand } from '@aws-sdk/client-sqs'
import { type GetQueueAttributesCommandInput } from '@aws-sdk/client-sqs'
import { Schema } from '../amplify/data/resource'
import { publishError } from './ErrorHandler';


export default function QueueManagement() {
  const { sqsClient } = useContext(UserContext)!;
  const { queuesHook: { data: queues, create: createQueue, delete : deleteQueue } } = useContext(ManagementContext)!;
  const { projectMembershipHook: { data: projectMemberships, update: updateProjectMembership } } = useContext(ManagementContext)!;
  const [messageCounts, setMessageCounts] = useState<{ [key: string]: number }>({});
  

  const getSubscribedUsersCount = (queueId:string) => {
    return projectMemberships!.filter((pm) => pm.queueId === queueId).length;
  };

  async function getMessageCount(queueUrl:string) {
    try {
      const params : GetQueueAttributesCommandInput = {
        QueueUrl: queueUrl,
        AttributeNames: ['ApproximateNumberOfMessages'],
      };
      const result = await sqsClient.send(new GetQueueAttributesCommand(params));
      return parseInt(result.Attributes?.ApproximateNumberOfMessages||"0", 10);
    } catch (error) {
      console.error('Error fetching message count:', error);
      return -1;
    }
  }

  useEffect(() => {
    const updateMessageCounts = async () => {
      const newCounts:{[key: string]: number} = {};
      for (const queue of queues) {
        if (queue.url) {
          newCounts[queue.url] = await getMessageCount(queue.url);
        }
      }
      setMessageCounts(newCounts);
    };
    updateMessageCounts();
    const intervalId = setInterval(updateMessageCounts, 10000);
    return () => clearInterval(intervalId);
  }, [queues]);

  const deleteQueueHandler = async (queue:Schema['Queue']['type']) => {
    try {
       // TODO: Implement queue deletion logic
      // This should include:
      // 1. Deleting the queue from SQS
      // 2. Updating any users who were subscribed to this queue
      // 3. Removing the queue from the local state
      await deleteQueue(queue);
      console.log(`Queue ${queue.id} deleted successfully`);
    } catch (error) {
      console.error('Error deleting queue:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      publishError(`Error deleting queue: ${errorMessage}`);
    }
  };

  const unsubscribeAllUsers = async (queueId:string) => {
    try {
      console.log('Unsubscribing all users from queue:', queueId);
      const usersToUpdate = projectMemberships?.filter(pm => pm.queueId === queueId);
      if (usersToUpdate && usersToUpdate.length > 0) {
        await Promise.all(usersToUpdate.map(pm => updateProjectMembership({ id: pm.id, queueId: null })));
        console.log(`Unsubscribed ${usersToUpdate.length} users from queue ${queueId}`);
      } else {
        console.log(`No users subscribed to queue ${queueId}`);
      }
    } catch (error) {
      console.error('Error unsubscribing users:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      publishError(`Error unsubscribing users from queue: ${errorMessage}`);
    }
  };

  const purgeQueueHandler = async (queueUrl:string) => {
    try {
      console.log('Purging queue:', queueUrl);
      await sqsClient.send(new PurgeQueueCommand({QueueUrl: queueUrl}));
      console.log(`Queue ${queueUrl} purged successfully`);
    } catch (error) {
      console.error('Error purging queue:', error);
      const errorMessage = error instanceof Error ? error.message : 'Unknown error';
      publishError(`Error purging queue: ${errorMessage}`);
    }
  };

  const tableData = queues
    ?.map((queue) => {
      const subscribedUsersCount = getSubscribedUsersCount(queue.id);
      const messageCount = queue.url ? messageCounts[queue.url] : 0;
      const isDeleteDisabled = (subscribedUsersCount > 0) || (messageCount > 0);

      const deleteTooltip = (
        <Tooltip id={`tooltip-${queue.url}`}>
          Queue must be empty and have no subscribed users to be eligible for deletion.
        </Tooltip>
      );

      return {
        id: queue.id,
        name: queue.name, // Add this line to include the name for sorting
        rowData: [
          queue.name,
          subscribedUsersCount,
          <span key={`${queue.url}-count`}>{messageCount}</span>,
          <div key={`${queue.url}-actions`}>
            <Button variant="warning" className="me-2" onClick={() => unsubscribeAllUsers(queue.id)}>
              Unsubscribe All
            </Button>
            <Button variant="info" disabled={!(queue.url)} className="me-2" onClick={() => purgeQueueHandler(queue.url!)}>
              Purge Queue
            </Button>
            <OverlayTrigger
              placement="top"
              overlay={deleteTooltip}
              trigger={['hover', 'focus']}
              show={isDeleteDisabled ? undefined : false}
            >
              <span>
                <Button 
                  className="me-2"
                  variant="danger" 
                  onClick={() => deleteQueueHandler(queue)}
                  disabled={isDeleteDisabled}
                >
                  Delete
                </Button>
              </span>
            </OverlayTrigger>
          </div>,
        ],
      };
    })
    .sort((a, b) => a.name.localeCompare(b.name)); // Sort the tableData array by name

  const tableHeadings = [
    { content: 'Queue Name' , style: { width: "300px" } },
    { content: 'Subscribed Users' },
    { content: 'Messages in Queue' },
    { content: 'Actions' },
  ];

  const addQueue = () => {
    const queueName = prompt("Please enter the name for the new queue:");
    if (queueName) {
      console.log('Adding new queue:', queueName);
      createQueue(queueName);
      // TODO: Implement actual queue creation logic
    }
  };

  return (
    <Row className="justify-content-center mt-3">
      <div>
        <h2>Queue Management</h2>
        <MyTable tableHeadings={tableHeadings} tableData={tableData || []} />
        <Col className="text-center mt-3">
          <Button variant="primary" onClick={addQueue}>
            Add New Queue
          </Button>
        </Col>
      </div>
    </Row>
  );
}
